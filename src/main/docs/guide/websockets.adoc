Our final server-side feature is to push “session timeout” events to the
client over a websocket connection. We’ll use another Grails plugin, the
https://plugins.grails.org/plugin/zyro/grails-spring-websocket[Spring
Websocket plugin], to support this feature.

Install the plugin by adding another line to our `build.gradle` file:

[source, groovy]
./server/build.gradle
----
include::{sourceDir}/server/build.gradle[indent=0,lines=53]
----

We now have to implement three classes to get our web socket session
timeout working:

1.  A configuration class to configure our websocket connection
2.  A “listener” class to keep track of when new authentication tokens
are created
3.  A “scheduler” class to periodically check for “expired” sessions and
push events over the websocket connection.

Because these classes are not Grails-specific, we will create them as
Groovy classes under `server/src/main/groovy`.

Here is the complete code for these three classes:

[source, groovy]
./server/src/main/groovy/ice/cream/CustomWebSocketConfig.groovy
----
include::{sourceDir}/server/src/main/groovy/ice/cream/CustomWebSocketConfig.groovy[]
----

[source, groovy]
./server/src/main/groovy/ice/cream/TokenCreationEventListener.groovy
----
include::{sourceDir}/server/src/main/groovy/ice/cream/TokenCreationEventListener.groovy[]
----

[source, groovy]
./server/src/main/groovy/ice/cream/SessionExpirationJobHolder.groovy
----
include::{sourceDir}/server/src/main/groovy/ice/cream/SessionExpirationJobHolder.groovy[]
----

With these classes in place, we need to plug them into the Spring
context by adding them as “beans” in our `resources.groovy` file. Edit
the file as shown below.

[source, groovy]
./server/grails-app/conf/spring/resources.groovy
----
include::{sourceDir}/server/grails-app/conf/spring/resources.groovy[]
----

We have a couple loose ends to tidy up, and then we’ll be done with the
server.

Sharp readers will have noticed that in two of these classes we
referenced a `lastLogin` property on the `User` domain class, but we
haven’t actually added that property yet! Let’s do that next. Edit the
`User` class and use the following content (be sure to use the entire
file as shown below).


[source, groovy]
./server/grails-app/domain/ice/cream/User.groovy
----
include::{sourceDir}/server/grails-app/domain/ice/cream/User.groovy[]
----


There’s a lot of code in that class! Almost all of this code was
generated by the Spring Security plugin, of course - just make sure to
add the two lines marked with comments above.

Next, in order for our scheduled `SessionExpirationJobHolder` class to
actually fire as scheduled, we have to enable scheduling in our
application (it’s not on by default). We do that by editing our app’s
`Application.groovy` file (note the capitalization!).

[source, groovy]
./server/grails-app/init/ice/cream/Application.groovy
----
include::{sourceDir}/server/grails-app/init/ice/cream/Application.groovy[]
----

And finally, you may remember we referenced a couple of new config
properties in the classes above. Let’s add those to our
`application.yml` file (add the lines below to the end of the file).

[source, yml]
./server/grails-app/conf/application.yml
----
include::{sourceDir}/server/grails-app/conf/application.yml[indent=0,lines=129-130]
----

TIP: Grails applications can read config values set in a variety of
ways, including YAML files, Groovy files, and system properties. See the
http://docs.grails.org/latest/guide/conf.html[Grails documentation] for
more on how to use configuration files.

That’s all for the Grails backend server - we have support for CORS (out
of the box), websockets, authentication, RESTful web services, SSL, and
scheduled methods, and persistence to PostgresSQL.
